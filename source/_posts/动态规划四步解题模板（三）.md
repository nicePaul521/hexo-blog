---
title: 动态规划四步解题模板（三）
author: paul yu
toc: true
categories:
- 算法
- 教程
tas: 动态规划
---

# 概述

我们分析了矩阵类动态规划，说到这类动态规划通常在一个矩阵中进行，我们只需要考虑当前位置的信息即可，分析并定义状态的时候，也只需要分析当前位置和其相邻位置的关系，通常这样做就可以达到拆解问题的目的。

这次再来看一类动态规划问题，**序列类动态规划问题**，这类动态规划问题较为普遍，分析难度相比之前也略有提升，通常问题的输入参数会涉及数组或是字符串。

在开始之前，先解释一下子数组（子串）和子序列的区别，你可以看看下面这个例子：

```
输入数组：[1,2,3,4,5,6,7,8,9]
子数组：[2,3,4], [5,6,7], [6,7,8,9], ...
子序列：[1,5,9], [2,3,6], [1,8,9], [7,8,9], ...
```

可以看到的是，**子数组必须是数组中的一个连续的区间，而子序列并没有这样一个要求**。

你只需要保证子序列中的元素的顺序和原数组中元素的顺序一致即可，例如，在原数组中，元素 1 出现在元素 9 之前，那么在子序列中，如果这两个元素同时出现，那么 1 也必须在 9 之前。

为什么要说这个？

不知道你有没有发现，这里的子数组的问题和我们前面提到的矩阵类动态规划的分析思路很类似，只需要考虑当前位置，以及当前位置和相邻位置的关系。

通过这样的分析就可以把之前讲的内容和今天要介绍的内容关联起来了，相比矩阵类动态规划，序列类动态规划最大的不同在于，**对于第 i 个位置的状态分析，它不仅仅需要考虑当前位置的状态，还需要考虑前面 i - 1 个位置的状态**，这样的分析思路其实可以从子序列的性质中得出。

对于这类问题的问题拆解，有时并不是那么好发现问题与子问题之间的联系，但是通常来说思考的方向其实在于 **寻找当前状态和之前所有状态的关系**，我们通过几个非常经典的动态规划问题来一起看看。

# 题目分析

## 最长上升子序列

### 题目描述

给定一个无序的整数数组，找到其中最长上升子序列的长度

实例：

>输入: [10,9,2,5,3,7,101,18]
>输出: 4 
>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4

说明：

-   可能有多种最长上升子序列的组合，只需要输出对应的长度即可。
-   算法的时间复杂度应该为O(n^2)

### 题目解析

给定一个数组，求其最长递增子序列。`因为是子序列，这样对于每个位置的元素都存在两种可能，就是选和不选`。如果用暴力法，枚举出所有的子序列，然后判断它们是不是递增的，选取最大的递增序列，时间复杂度为O(2^n)，显然不够高效。

这里就需要思考用动态规划进行优化，按之前的四个步骤具体分析一下：

-   问题拆解

    我们要求解的问题是“数组中的最长递增子序列”，一个子序列虽然不是连续的空间，但是它始终有起点和终点，比如：

    ```
    [10,9,2,5,3,7,101,18]
    
    子序列 [2,3,7,18] 的起始位置是 2，终止位置是 18
    子序列 [5,7,101] 的起始位置是 5，终止位置是 101
    ```

-   状态定义

    问题拆解中我们提到了"第i个问题和前i-1个问题有关"，也就是说“如果我们求解第i个问题的解，那么必须考虑前i-1个问题的解”。我们定义`dp[i]表示以位置i结尾的子序列最大长度`，也就是说dp[i]里面记录的答案保证了该答案表示的子序列以位置i结尾。

-   递推方程

    对于i这个位置，我们需要考虑前i-1个位置，看看哪些位置可以拼在i位置之前，如果有多个位置可以拼在i之前，那么必须选最长的那个。这样一分析，递推方程就有了：

    `dp[i] = max(dp[j],...dp[k])+1,其中array[j]<array[i],array[k]<array[j]`

-   实现

    在实现这里，我们需要考虑状态数组的初始化，因为对于每个位置其本身都是一个序列，因此所有位置的状态可以初始化为1.

### 参考代码

```java
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }

    // dp[i] -> the longest length sequence from 0 - i, and must include nums[i]
    int[] dp = new int[nums.length];

    Arrays.fill(dp, 1);

    int max = 0;

    for (int i = 0; i < nums.length; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[j] + 1, dp[i]);
            }
        }

        max = Math.max(max, dp[i]);
    }

    return max;
}
```

## 粉刷房子

### 题目描述

假如一排房子，共n个，每个房子都被粉刷成红色，蓝色或者绿色这三种颜色中的一种，你需要粉刷所有房子并使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色的油漆价格不同，所以房子粉刷成本也是不同的。每个房子粉刷成不同颜色的花费是以一个nx3的矩阵来表示的。

例如，`costs[0][0]`表示0号房子粉刷成红色的成本花费；`costs[1][2]`表示第1号房子粉刷成绿色的花费，以此类推。计算出粉刷完所有房子的最少花费成本 。

注意：所有花费均为正整数

实例：

>   输入: [[17,2,17],[16,16,5],[14,3,19]]
>   输出: 10
>   解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。
>      最少花费: 2 + 5 + 3 = 10。

### 题目解析

给 n 个房子刷油漆，有三种颜色的油漆可以刷，必须保证相邻房子的颜色不能相同，输入是一个 n x 3 的数组，表示每个房子使用每种油漆所需要花费的价钱，求刷完所有房子的最小价值。

还是按原来的思考方式走一遍：

-   问题拆解

    对于每个房子，都可以使用三种油漆中的一种，如果说不需要保证相邻房子的颜色不必不同，那么整个题目变得非常简单，每个房子直接用最便宜的油漆刷就好了，但是如果加上这个限制条件，就会发现刷第i个房子的花费和前面i-1个房子的花费以及选择有关，如果我们需要直到第i个房子使用第k种油漆的最小花费，其实可以思考第i-1个房子不使用该油漆的最小nnnnnnnnnnnnnnnnnn花费，这个最小花费是考虑从0到当前位置所有房子的。

-   状态定义

    通过之前的问题拆解，状态可以定义为dp\[i][k],表示如果第i个房子选择第k个颜色，那么从0到i个房子的最小花费。

-   递推方程

    基于之前的状态定义，以及相邻的房子不能使用相同的油漆，那么递推方程就是：

    `dp[i][k] = min(dp[i-1][l],...dp[i-1][k])+cost[i][k].l!=k,r!=k`

-   实现

    因为要考虑i-1的情况，但是第0个房子并不存在i-1的情况，因此可以考虑把第0个房子的最小花费保存在状态数组中。

### 参考代码

```java
public int minCost(int[][] costs) {
    if (costs == null || costs.length == 0) {
        return 0;
    }
    int n = costs.length;

    int[][] dp = new int[n][3];

    for (int i = 0; i < costs[0].length; ++i) {
        dp[0][i] = costs[0][i];
    }

    for (int i = 1; i < n; ++i) {
        dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]) + costs[i][0];
        dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]) + costs[i][1];
        dp[i][2] = Math.min(dp[i - 1][0], dp[i - 1][1]) + costs[i][2];
    }

    return Math.min(dp[n - 1][0], Math.min(dp[n - 1][1], dp[n - 1][2]));
}
```

## 粉刷房子Ⅱ

### 题目描述

假如一排房子，共n个，每个房子可以被粉刷成k种颜色中的一种，需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色的油漆价格不同，所以房子粉刷成不同颜色的是以一个nxk的矩阵来表示的。

例如，`costs[0][0]`表示第0号房子粉刷成0号颜色的成本花费；`costs[1][2]`表示1号房子粉刷成2号颜色的成本花费，以此类推。请计算出粉刷完所有房子的最少花费成本。

注意：所有花费均为正整数。

实例：

>   输入: [[1,5,3],[2,9,4]]
>   输出: 5
>   解释: 将 0 号房子粉刷成 0 号颜色，1 号房子粉刷成 2 号颜色。最少花费: 1 + 4 = 5; 或者将 0 号房子粉刷成 2 号颜色，1 号房子粉刷成 0 号颜色。最少花费: 3 + 2=5

### 题目解析

现在不是三种油漆，而是k种油漆，解题思路还是不变，对于第i个房子的每种颜色，我们要对比第i-1个房子的k种油漆，找到不相同颜色的最小者就好，这里的时间夫再度是O（nk^2）.

其实这是可以优化的，只需要在i-1个位置的状态中找到最大值和次大值，在选择第i个房子的时候，我们要看当前颜色是不是和最大值的颜色相同，不是的话就直接加上最大值，如果相等的话，我们就加上次大值，这样一来我么把两个嵌套的循环，拆开成两个平行的循环，时间复杂度降至O（nk）.

### 参考代码（优化前）

```java
public int minCostII(int[][] costs) {
    if (costs.length == 0 || costs[0].length == 0) {
        return 0;
    }

    int n = costs.length, k = costs[0].length;
    int[][] dp = new int[n][k];

    for (int i = 1; i < n; ++i) {
        Arrays.fill(dp[i], Integer.MAX_VALUE);
    }

    for (int i = 0; i < k; ++i) {
        dp[0][i] = costs[0][i];
    }        

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < k; ++j) {
            for (int m = 0; m < k; ++m) {
                if (m != j) {
                    dp[i][m] = Math.min(dp[i][m], dp[i - 1][j] + costs[i][m]);
                }
            }
        }
    }

    int result = Integer.MAX_VALUE;
    for (int i = 0; i < k; ++i) {
        result = Math.min(result, dp[n - 1][i]);
    }

    return result;
}
```

### 参考代码（优化后）

```java
public int minCostII(int[][] costs) {
    if (costs.length == 0 || costs[0].length == 0) {
        return 0;
    }

    int n = costs.length, k = costs[0].length;
    int[][] dp = new int[n][k];

    for (int i = 1; i < n; ++i) {
        Arrays.fill(dp[i], Integer.MAX_VALUE);
    }

    for (int i = 0; i < k; ++i) {
        dp[0][i] = costs[0][i];
    }

    for (int i = 1; i < n; ++i) {
        // min1 表示的是最大值，min2 表示的是次大值
        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
        int minIndex = -1;
        for (int l = 0; l < k; ++l) {
            if (min1 > dp[i - 1][l]) {
                min2 = min1;
                min1 = dp[i - 1][l];
                minIndex = l;
            } else if (min2 > dp[i - 1][l]) {
                min2 = dp[i - 1][l];
            }
        }

        for (int j = 0; j < k; ++j) {
            if (minIndex != j) {
                dp[i][j] = Math.min(dp[i][j], min1 + costs[i][j]);
            } else {
                dp[i][j] = Math.min(dp[i][j], min2 + costs[i][j]);
            }
        }
    }

    int result = Integer.MAX_VALUE;
    for (int i = 0; i < k; ++i) {
        result = Math.min(result, dp[n - 1][i]);
    }

    return result;
}
```

## 打家劫舍

### 题目描述

你是一个专业的小偷，计划盗窃沿街的房屋，每个房屋内都藏有一定的现金，如果影响你偷窃的唯一制约因素是相邻的房屋装有的相互连通的防盗系统，`如果两个相邻的房屋在同一晚上被小偷闯入，系统会自动报警`

给定一个代表每个房屋存放金额的非负整数数组，计算你在`不触动警报装置的情况下，能够盗窃到的最高金额`。

实例1：

>   输入: [1,2,3,1]
>   输出: 4
>   解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。

实例2：

>   输入: [2,7,9,3,1]
>   输出: 12
>   解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。

![](http://image-paul-blogs.test.upcdn.net/algorithm/a03.jpg)

### 题目解析

条件和前面类似，就是相邻的房子不能抢，老样子，四个步骤走一遍：

-   问题拆解

    如果我们要求解抢完n个房子所获得的最大收入，因为题目要求，我们可以思考第i个房子是否该枪，如果要抢，那么第i-1个房子就不能抢，那么只能考虑抢第i-2个房子。如果不抢，那么就可以抢第i-1个房子，这样以来，第i个房子就和第i-1个房子以及第i-2个房子联系起来。

-   状态定义

    通过之前的问题拆解，我们知道，如果我们从左往右去抢房子，抢到当前房子可以获得的最大值其实和抢到前两个房子获得的最大值有关。因此`dp[i]表示抢到第i个房子获得的最大值`

-   递推方程

    如果我们抢第i个房子，那么我们就只能去考虑i-2个房子，如果我们不抢，那么可以考虑第i-1个房子，于是递推方程就是：

    `dp[i] = max(dp[i-2]+nums[i],dp[i-1])`

-   实现

    因为第i个位置和前面两个位置都有关，这个时候可以把状态多开一个，dp[0]表示的是一个房子都不抢的状态，dp[1]表示最左边的房子获得的最大价值，这个房子之前没有其他房子，直接抢即可。

### 参考代码

```java
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }

    int n = nums.length;

    int[] dp = new int[n + 1];

    dp[1] = nums[0];

    for (int i = 2; i <= n; ++i) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);
    }

    return dp[n];
}
```

## 打家劫舍Ⅱ

### 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋，每间房屋内都藏有一定的现金。这个地方的房屋都`围成一圈`，意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，`如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警`。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动报警装置的情况下，能够盗窃到的最高金额。

实例1：

>   输入: [2,3,2]
>   输出: 3
>   解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为它们是相邻的

实例2:

>   输入: [1,2,3,1]
>   输出: 4
>   解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4 。

### 题目解析

按照前面那道题 follow up，问的是如果这些房子排列方式是一个圆圈，其余要求不变，问该如何处理。

房子的排列是一个圆圈，意味着之前的最后一个房子和第一个房子之间产生了联系，这里的小技巧就是我们线性考虑[0,n-2]和[1,n-1]，然后求两者的最大值。

这样做的意图很明显，把第一个房子和最后一个房子单独考虑，实现上面我们可以直接使用之前的实现代码。

这里的一个边界条件就是，当只有一个房子时，我们直接输出结果即可。

### 参考代码

```java
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }

    if (nums.length == 1) {
        return nums[0];
    }

    int n = nums.length;

    return Math.max(
                    robI(Arrays.copyOfRange(nums, 0, n - 1)),
                    robI(Arrays.copyOfRange(nums, 1, n))
                   );
}

public int robI(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }

    int n = nums.length;

    int[] dp = new int[n + 1];

    dp[1] = nums[0];

    for (int i = 2; i <= n; ++i) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);
    }

    return dp[n];
}
```

# 总结

序列类动态规划的系列问题还有很多，比如股票问题，这类问题通常给你一个数组或者字符串，在分析这些问题的时候，要考虑当前状态的选择是否基于前面的状态，以及它们的关系是什么。

>   以上内容转载于微信公众号：五分钟学算法

![](http://image-paul-blogs.test.upcdn.net/algorithm/a04.jpg)