---
title: 动态规划四步解题模板（一）
author: paul yu
toc: true
categories:
- 算法
- 教程
tags: 动态规划
---

# 导言

动态规划一直是算法面试中的重点与难点，并且动态规划这种通过空间换时间的算法思想在实际工作中会频繁用到，这篇文章主要是解释清楚`什么是动态规划？`,还有就是面对一道动态规划题目，一般的思考步骤以及注意事项。

# 什么是动态规划

用一句话解释就是`记住你以前做过的事`，如果更准确一些，就是`记住你以前得到的答案`。

在软件开发中，大家经常会遇到一些系统配置的问题，配置不对，系统就会报错，这个时候一般都会去 Google 或者是查阅相关的文档，花了一定的时间将配置修改好。

过了一段时间，去到另一个系统，遇到类似的问题，这个时候已经记不清之前修改过的配置文件长什么样，这个时候有两种方案，一种方案还是去 Google 或者查阅文档，另一种方案是借鉴之前修改过的配置，第一种做法其实是万金油，因为你遇到的任何问题其实都可以去 Google，去查阅相关文件找答案，但是这会花费一定的时间，相比之下，第二种方案肯定会更加地节约时间，但是这个方案是有条件的，条件如下：

-   之前的问题和当前的问题存在着关联性，换句话说，之前问题得到的答案可以帮助解决当前问题
-   需要记录之前问题的答案

对于动态规划问题，只需要从两个方面考虑，那就是`找出问题之间的联系`以及`记录答案`。难点是找出问题之间的联系。

# 思考动态规划问题的四个步骤

-   问题拆解，找到问题之间的具体联系
-   状态定义
-   递推方程的推导
-   实现

重点是前两个，如果前两个步骤顺利完成，后面的递推方程的推导和代码实现变得非常简单。

这里还是拿 Quora 上面的例子来讲解，“1+1+1+1+1+1+1+1” 得出答案是 8，那么如何快速计算 “1+ 1+1+1+1+1+1+1+1”，我们首先可以对这个大的问题进行拆解，这里我说的大问题是 9 个 1 相加，这个问题可以拆解成 1 + “8 个 1 相加的答案”，8 个 1 相加继续拆，可以拆解成 1 + “7 个 1 相加的答案”，… 1 + “0 个 1 相加的答案”，到这里，**第一个步骤** 已经完成。

**状态定义** 其实是需要思考在解决一个问题的时候我们做了什么事情，然后得出了什么样的答案，对于这个问题，当前问题的答案就是当前的状态，基于上面的问题拆解，你可以发现两个相邻的问题的联系其实是 `后一个问题的答案 = 前一个问题的答案 + 1`，这里，状态的每次变化就是 +1。

定义好了状态，递推方程就变得非常简单，就是 `dp[i] = dp[i - 1] + 1`，这里的 `dp[i]` 记录的是当前问题的答案，也就是当前的状态，`dp[i - 1]` 记录的是之前相邻的问题的答案，也就是之前的状态，它们之间通过 +1 来实现状态的变更。

最后一步就是实现了，有了状态表示和递推方程，实现这一步上需要重点考虑的其实是初始化，就是用什么样的数据结构，根据问题的要求需要做那些初始值的设定。

```java
public int dpExample(int n){
    int[]  = new int[n+1];
    dp[0] = 0;
    for(int i=1;i<=n;i++){
        dp[i] = dp[i-1]+1;
    }
    return dp[n];
}
```

接下来再来看看leetcode上面的几道题目，通过题目分析。

# 题目实战

## 爬楼梯

### 题目描述

假设正在爬楼梯，需要n阶台阶才能到达楼顶，每次可以爬1或2个台阶，由多少种不同的方法可以到达楼梯顶呢？

注意：给定n是一个正整数。

实例1：

>   输入：2
>
>   输出：2
>
>   解释：有两种方法可以到达楼顶
>
>   1.  1+1
>   2.  2

实例2：

>   输入：3
>
>   输出：3
>
>   解释：有三种方法可以爬到楼顶
>
>   1.  1+1+1
>   2.  1+2
>   3.  2+1

### 题目解析

我们按照上面提到的4个步骤进行分析：

-   问题拆解：

    我们到达第n个楼梯可以从第n-1个楼梯和第n-2个楼梯到达，因此第n个问题可以拆解成第n-1个问题和第n-2个问题，第n-1个问题和第n-2个问题又可以继续往下拆，直到第0个问题。

-   状态定义

    “问题拆解”中已经提到了，第n个楼梯会和第n-1和第n-2个楼梯有关联，那具体的联系是什么呢？第n-1个问题的答案就是从起点到达n-1个楼梯的路径总数，n-2同理。从n-1个楼梯可以到达第n个楼梯，从n-2个楼梯也可以，并且路径没有重复，因此把第i个状态定义为`从起点到达第i个楼梯的路径总数`，状态之间的联系其实是相加的关系。

-   递推方程

    “状态定义”中已经定义好了状态，也知道了第i个状态可以由第i-1个状态和第i-2个状态相加得到，因此递推方程就是：`dp[i]=dp[i-1]+dp[i-2]`

-   实现

    其实从递推方程可以 看到，需要一个初始值方便我们计算，起始位置不需要移动`dp[0]=0`,第1层楼梯只能从起始位置到达，因此`dp[1]=1`,在第二层楼梯可以由起始位置和第一层楼梯到达，因此`dp[2]=2`。有了这些初始值，后面的值就可以由这些初始值递推得到。

### 参考代码

```java
public int climbStairs(int n) {
    if (n == 1) {
        return 1;
    }

    int[] dp = new int[n + 1];  // 多开一位，考虑起始位置

    dp[0] = 0; dp[1] = 1; dp[2] = 2;
    for (int i = 3; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}
```

## 三角形最小路径和

### 题目描述

给定一个三角形，找出自顶向下的最小路径和，每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

[
   [2],
  [3,4],
  [6,5,7],
 [4,1,8,3]
]

自顶向下的最短路径和是11（2+3+5+1=11）

### 题目解析

给定一个三角形数组，需要求出从上到下的最小路径和，按照四个步骤分析：

-   问题求解

    这里的总问题是求出最小路径的和，路径是这里的分析重点，路径是由一个个元素组成的，和之前爬楼梯的题目类似，`[i][j]`位置的元素，经过这个位置的元素肯定也经过`[i-1][j]`或者`[i-1][j-1]`，因此经过一个元素的路径和可以通过这个元素的上面一个或者两个的元素路径和得到。

-   状态定义

    状态的定义一般会和问题需要求解的答案联系到一起，这里有两种方式，一种考虑路径从上到下，另外一种是考虑路径从下到上。因为元素的值是不变的，所以路径的方向不会影响最后求得的路径和，如果是从上到下，会发现起始元素的路径只会从`[i-1][j]`获得，每行当中的最后一个元素只会从`[i-1][j-1]`获得。中间两者皆可，这样不太好实现，因此这里考虑从下到上的方式，状态的定义变成了`最后一行元素到当前元素的最小路径和`，对于\[0][0]这个元素来说，最后状态就是我们的最终答案。

-   递推方程

    “状态定义”中已经定义好了状态，递推方程就出来了

    `dp[i][j] = min(dp[i+1][j],dp[i+1][j+1])+triangle[i][j]`

-   实现

    这里初始化时需要将最后一行的元素填入状态数组中，然后就是按照前面分析的策略，从下到上计算即可。

### 参考代码

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
	int n,tmp;
	cin>>n;
	int trangle[n][n] = {-1};
	int dp[n][n];
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<i+1;j++)
		{
			cin>>tmp;
			trangle[i][j] = tmp;
			if(i==n-1)
			{
				dp[n-1][j] = tmp;
			}
		}
	}
	for(int i=n-2;i>=0;i--)
	{
		for(int j=0;j<i+1;j++)
		{
			dp[i][j] = min(dp[i+1][j],dp[i+1][j+1])+trangle[i][j];
		}
	}
	cout<<dp[0][0];
	return 0;
}
```

## 最大子序和

### 题目描述

给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

实例：

>   输入：[-2,1,-3,4,-1,2,1,-5,4]
>
>   输出：6
>
>   解释：连续子数组[4,-1,2,1]的和最大，为6.

### 题目解析

求最大子数组和，有不同的解法，比如动态规划，贪心，分治还有一些技巧性的东西，比如前缀和数组，这里用动态规划的思想来解题。

-   问题拆解

    问题的核心是子数组，子数组可以看作是一段区间，因此可以从起点和终点来确定一个子数组，两个点中先确定一个点，然后再去找另外一个点，比如说，如果确定一个子数组的截至元素在i位置，这时候需要思考的是`以i结尾的所有子数组中，和最大的是多少？`，试着去拆解，这里只有两种情况：

    -   i这个位置的元素自成一个子数组
    -   i位置的元素的值+`i-1结尾的的所有子数组和最大的值`

​       可以看到，我们把第i个问题拆解成第i-1个问题，之间的联系也变得清晰。

-   状态定义

    `dp[i]`就是`以i结尾的所有子数组的最大值`

-   递推方程

    拆解问题的时候也提到了，有两种情况，即当前元素自成一个子数组，或者考虑前一个状态的答案。于是就有了：

    `dp[i] = max(dp[i-1]+array[i],array[i])`

    等价于：

    `dp[i] = max(dp[i-1],0)+array[i]`

-   实现

    题目要求子数组不能为空，因此一开始就需要初始化，也就是`dp[0]=array[0]`,为了保证最后答案的可靠性，需要初始化一个变量记录最后的答案，因为子数组有可能以数组任意一个元素结尾。

### 参考代码

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
	int n,tmp; 
	cin>>n;
	vector<int> nums;
	vector<int> dp(n); 
	for(int i=0;i<n;i++)
	{
		cin>>tmp;
		nums.push_back(tmp);
	}
	for(int i=1;i<n;i++)
	{
		dp[i] = max(dp[i-1],0)+nums[i];
	}
	cout<<*max_element(dp.begin(),dp.end());
	return 0;
}
```

# 总结

通过以上几个简单的例子，不难发现，动态规划类题目就是拆解问题，定义状态的过程，这种思想强调的是从局部最优通过一定的策略推到全局最优解 ，从子问题答案一步步推出整个问题的答案，并且利用空间换时间，降低时间复杂度。